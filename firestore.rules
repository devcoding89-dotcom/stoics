/**
 * @fileOverview Firestore Security Rules for Stoics Educational Services application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data,
 * while allowing public read access to certain collections like announcements.
 * Google Authentication is taken into account.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`.
 * - Lessons are nested under teachers: `/users/{teacherId}/lessons/{lessonId}`.
 * - Attendance records are nested under both students and lessons for efficient querying:
 *   - `/users/{studentId}/attendances/{attendanceId}`
 *   - `/users/{teacherId}/lessons/{lessonId}/attendances/{attendanceId}`
 * - Payments are associated with students: `/users/{studentId}/payments/{paymentId}`.
 * - Chat messages are stored in a top-level collection: `/chat_messages/{messageId}`.
 * - Announcements are stored in a top-level collection: `/announcements/{announcementId}`.
 * - AI Tutoring Contexts are stored in a top-level collection: `/ai_tutoring_contexts/{contextId}`.
 *
 * Key Security Decisions:
 * - User listing is disallowed for non-admins. Admins can list all users.
 * - Teachers can list users with the 'student' role.
 * - Announcements are publicly readable but writable only by authorized users (teachers/admins)
 * - Data consistency is enforced between document IDs and path parameters.
 * - All write operations require a verified user identity (`request.auth != null`), except for OTP updates.
 * - **Payment Before Class**: Students with overdue payments are blocked from reading lesson data.
 * - **Role Management**: Only Admins can change a user's role.
 *
 * Denormalization for Authorization:
 * - Attendance records nested under lessons include a denormalized `teacherId` to avoid `get()` calls
 *   when enforcing attendance write rules.
 *
 * Structural Segregation:
 * - Announcements are stored in a separate top-level collection for public read access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  
    /**
     * @description Secures user profiles. Users can read/write their own profile. Admins can read all profiles. Teachers can read students.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin() || (isTeacher() && isStudent(userId));
      // Admins can list all users. Teachers can list users with the 'student' role.
      // Any authenticated user can count documents (for registration number generation) but not read data.
      allow list: if (isAdmin() || (isTeacher() && request.query.get("where")[0][2] == 'student') || (isSignedIn() && request.query.limit == 0));
      // Allow a user to create their own user document.
      allow create: if isOwner(userId);
      // Allow updating own profile (but not role), admin updating any profile, or unauthenticated OTP update.
      allow update: if (isExistingOwner(userId) && isNotChangingRole()) || isUpdatingOtp() || isAdmin();
      allow delete: if (isExistingOwner(userId) && request.auth.uid == userId) || isAdmin();

      /**
       * @description Secures lessons nested under a teacher.
       * @path /users/{teacherId}/lessons/{lessonId}
       */
      match /lessons/{lessonId} {
        // Teacher can do anything with their own lessons.
        // A student can read a lesson ONLY IF they don't have overdue payments.
        allow get: if isOwner(userId) || (isSignedIn() && !hasOverduePayments(request.auth.uid));
        allow list: if isOwner(userId) || (isSignedIn() && !hasOverduePayments(request.auth.uid));
        allow create: if isOwner(userId) && request.resource.data.teacherId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.teacherId == resource.data.teacherId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Secures attendance records for each student.
       * @path /users/{studentId}/attendances/{attendanceId}
       */
      match /attendances/{attendanceId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.studentId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.studentId == resource.data.studentId;
        allow delete: if isExistingOwner(userId);
      }
      
      /**
       * @description Secures payment records for each student.
       * @path /users/{studentId}/payments/{paymentId}
       */
      match /payments/{paymentId} {
        // Student can get/list their own payments.
        allow get, list: if isOwner(userId);
        // A teacher can create a payment request in a student's collection.
        allow create: if isTeacher() && request.resource.data.teacherId == request.auth.uid && request.resource.data.studentId == userId;
        // Student can update (to pay), teacher can update (e.g., correct amount).
        allow update: if isOwner(userId) || (isTeacher() && resource.data.teacherId == request.auth.uid);
        allow delete: if isTeacher() && resource.data.teacherId == request.auth.uid;
      }
    }

    /**
     * @description Collection group query rules for 'lessons'.
     */
    match /{path=**}/lessons/{lessonId} {
       // Allow signed-in users to read lessons if they are an admin, the teacher,
       // or if they are a student associated with the lesson AND have no overdue payments.
       allow get: if isSignedIn() && (isAdmin() || isTeacher() || (request.auth.uid in resource.data.studentIds && !hasOverduePayments(request.auth.uid)));
       allow list: if isSignedIn() && (isAdmin() || isTeacher() || (request.auth.uid in resource.data.studentIds && !hasOverduePayments(request.auth.uid)));
    }
    
    /**
     * @description Collection group query rules for 'payments'.
     */
    match /{path=**}/payments/{paymentId} {
       // Allow admins to list all payments across all users.
       allow list: if isAdmin();
    }

    /**
     * @description Secures denormalized attendance records nested under lessons. The teacher owns the lesson and attendance.
     * @path /users/{teacherId}/lessons/{lessonId}/attendances/{attendanceId}
     */
    match /users/{teacherId}/lessons/{lessonId}/attendances/{attendanceId} {
      allow get: if isOwner(teacherId);
      allow list: if isOwner(teacherId);
      allow create: if isOwner(teacherId) && request.resource.data.teacherId == teacherId;
      allow update: if isExistingOwner(teacherId) && request.resource.data.teacherId == resource.data.teacherId;
      allow delete: if isExistingOwner(teacherId);
    }

    /**
     * @description Secures chat messages. Any authenticated user can create chat messages.
     * @path /chat_messages/{messageId}
     */
    match /chat_messages/{messageId} {
      allow read, write: if isSignedIn();
    }

    /**
     * @description Secures global announcements. Announcements are publicly readable.
     * @path /announcements/{announcementId}
     */
    match /announcements/{announcementId} {
      allow get: if true;
      allow list: if true;
      allow create, update, delete: if isTeacherOrAdmin();
    }

    /**
     * @description Secures AI tutoring context.
     * @path /ai_tutoring_contexts/{contextId}
     */
    match /ai_tutoring_contexts/{contextId} {
      allow get: if true;
      allow list: if true;
      allow create, update, delete: if isTeacherOrAdmin();
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
      return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId));
  }
  
  function getUserData(userId) {
    return get(/databases/$(database)/documents/users/$(userId)).data;
  }
  
  function isAdmin() {
    return isSignedIn() && getUserData(request.auth.uid).role == 'admin';
  }

  function isTeacher() {
    return isSignedIn() && getUserData(request.auth.uid).role == 'teacher';
  }

  function isStudent(userId) {
    return getUserData(userId).role == 'student';
  }
  
  function isTeacherOrAdmin() {
    let userRole = getUserData(request.auth.uid).role;
    return isSignedIn() && (userRole == 'admin' || userRole == 'teacher');
  }
  
  function isUpdatingOtp() {
    let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
    return !isSignedIn() && changedKeys.hasAll(['otp', 'otpExpiry']) && changedKeys.size() == 2;
  }

  function hasOverduePayments(userId) {
    // If the user is a teacher or admin, this check does not apply.
    let userRole = getUserData(userId).role;
    if (userRole == 'teacher' || userRole == 'admin') {
      return false;
    }
    // Check if there are any documents in the user's payments subcollection
    // with the status 'overdue'. The size() of this query must be 0 for access to be granted.
    return exists(/databases/$(database)/documents/users/$(userId)/payments?status=overdue);
  }
  
  function isNotChangingRole() {
    // Users cannot change their own role. Only an admin can.
    return request.resource.data.role == resource.data.role;
  }
}
